# Bölüm 13: Vektör Veritabanları - Yapay Zekanın Anlamsal Hafızası
Elimizde artık metinleri, görselleri ve diğer yapılandırılmamış verileri temsil eden anlamsal vektörler (embeddings) var. Peki, bu vektörlerden milyonlarcasına sahip olduğumuzda ne yapacağız?

Mühendislik problemi şudur: Bir kullanıcı sorgu ("kırmızı spor ayakkabı") gönderdiğinde, bu sorguyu bir vektöre dönüştürdük. Şimdi, depomuzdaki 10 milyon ürün vektörü arasından bu sorgu vektörüne anlamsal olarak en yakın olanları nasıl bulacağız?

Geleneksel bir veritabanı (SQL gibi) bu iş için tasarlanmamıştır. SQL, yapılandırılmış verilerde tam eşleşmeler (`WHERE id = 10`) için optimize edilmiştir. Biz ise benzerlik (`bu vektöre en çok benzeyen 5 taneyi bul`) arıyoruz.

Milyonlarca kaydı tek tek kontrol etmek (`O(N)` karmaşıklığı) bir aramanın dakikalar sürmesine neden olur ki bu, kabul edilemez.

İşte bu noktada **Vektör Veritabanları** devreye girer.

## Temel İşlev: Anlam Hızında Arama
Vektör veritabanları, yüksek boyutlu vektörleri depolamak, yönetmek ve özellikle hızlı benzerlik araması yapmak için optimize edilmiş sistemlerdir.

Bunu, **Yaklaşık En Yakın Komşu (Approximate Nearest Neighbor - ANN)** adı verilen özel indeksleme algoritmalarıyla başarırlar.

> **ANN'nin temel fikri**, mühendislikte sıkça karşılaştığımız bir değiş tokuştur (trade-off): %100 mükemmel doğruluğu garanti etmek yerine (ki bu yavaştır), %99.9 doğrulukla "neredeyse mükemmel" sonucu 1000 kat daha hızlı vermeyi hedefler. Çoğu yapay zeka uygulaması (arama, tavsiye) için bu "yaklaşık" sonuç, yavaş gelen "mükemmel" sonuçtan çok daha değerlidir.

Bu veritabanları, vektörleri eklerken onları `HNSW` (Hierarchical Navigable Small Worlds) gibi verimli "haritalara" yerleştirir. Böylece bir arama geldiğinde, tüm evreni taramak yerine bu harita üzerinde en kısa yoldan en yakın komşulara ulaşırlar.

## Pratikte Süreç: İndeksleme ve Arama
Vektör veritabanlarıyla çalışmak iki temel aşamadan oluşur:

1.  **İndeksleme (Yazma):** Bu, veritabanını "doldurma" işlemidir.
    * Veri (metin, resim vb.) alınır.
    * Bir embedding modeli (Bölüm 12'de gördüğümüz) kullanılarak bu veri bir vektöre dönüştürülür.
    * Bu vektör, kendisiyle ilgili metadata (verinin asıl kaynağı, ID'si vb.) ile birlikte veritabanına `upsert` (ekle veya güncelle) edilir.
    * Veritabanı, bu yeni vektörü ANN indeksine yerleştirir.

2.  **Benzerlik Araması (Okuma):** Bu, "sorgulama" işlemidir.
    * Kullanıcının sorgusu (metin, resim vb.) alınır.
    * Aynı embedding modeli kullanılarak sorgu da bir vektöre dönüştürülür.
    * Bu sorgu vektörü veritabanına gönderilir ve "bana en yakın 5 komşuyu (K=5) bul" denir.
    * Veritabanı, sorgu vektörüne en yakın olan vektörlerin metadata'sını milisaniyeler içinde döndürür.

## Popüler Vektör Veritabanları: Ekosisteme Bakış
Pazarda bu işi yapan birçok oyuncu var ve her biri farklı bir ihtiyaca odaklanıyor. Doğru seçimi yapmak, projenizin mimarisini doğrudan etkiler.

### 1. Yönetilen Hizmetler (Managed Services - SaaS)
* **Pinecone:** Pazarın öncülerinden biridir. Altyapı yönetimiyle hiç uğraşmak istemeyenler için tasarlanmıştır. Yüksek performanslı, ölçeklenebilir ve kullanımı kolay bir API sunar. "Hizmet olarak vektör veritabanı" modelini popülerleştirmiştir.

### 2. Açık Kaynak ve Kendin Barındır (Open-Source & Self-Hosted)
* **Chroma:** Geliştirici dostu (developer-friendly) olmasıyla öne çıkar. Özellikle RAG (Retrieval-Augmented Generation) pipeline'ları ve yerel geliştirme için popülerdir. Python ile kolayca entegre olur.
* **Weaviate:** Sadece vektörleri değil, vektörlerle birlikte verinin kendisini de depolayan (vektör-native) bir veritabanıdır. Zengin filtreleme ve GraphQL arayüzü gibi güçlü özellikler sunar.
* **Qdrant:** Performans ve verimlilik üzerine odaklanmıştır (Rust ile yazılmıştır). Gelişmiş filtreleme, gerçek zamanlı güncellemeler ve yüksek ölçeklenebilirlik gerektiren uygulamalar için güçlü bir rakiptir.
* **LanceDB:** Sunucusuz (serverless) ve düşük gecikmeli mimarilere odaklanır. Kendi verimli "Lance" depolama formatını kullanarak hızlı okuma/yazma ve versiyonlama sunar.

### 3. Kütüphaneler (Libraries)
* **FAISS (Facebook AI Similarity Search):** Bu, tam bir veritabanı değil, bir **kütüphanedir**. Bu ayrım kritiktir. FAISS, ANN indeksleme ve aramasının çekirdek motorunu sağlar. Yüksek verimli benzerlik aramasının temel algoritmalarını sunar. Birçok veritabanı veya sistem, arka planda FAISS'in optimize edilmiş algoritmalarını kullanır.

### 4. Entegre Çözümler (Geleneksel DB + Vektör)
* **Supabase (pgvector ile):** "Zaten PostgreSQL kullanıyorum" diyenler için mükemmel bir çözümdür. `pgvector` eklentisi sayesinde, standart ilişkisel verilerinizin yanında vektörleri de depolamanıza ve aramanıza olanak tanır. Supabase, bu deneyimi paketleyip kolaylaştırır.
* **MongoDB Atlas:** Belge (document) veritabanı devi MongoDB, artık **Atlas Vector Search** özelliğini sunuyor. Bu, JSON belgelerinizin içinde vektörleri depolamanıza ve mevcut MongoDB ekosistemi içinde güçlü anlamsal aramalar yapmanıza olanak tanır.

Bu seçenekler arasındaki karar; ölçek, veri gizliliği (kendi sunucumda mı çalışmalı?), altyapı yönetimi bilgisi (managed mı, self-hosted mı?) ve mevcut teknoloji yığınınız (zaten bir MongoDB veya Postgres kullanıcısı mısınız?) gibi faktörlere bağlıdır.