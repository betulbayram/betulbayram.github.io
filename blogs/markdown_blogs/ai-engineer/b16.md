## BÃ¶lÃ¼m 16: Model Context Protocol (MCP) ğŸŒ - Yapay Zeka AjanlarÄ± Ä°Ã§in Evrensel Dil
Ã–nceki bÃ¶lÃ¼mde, bir ajanÄ±n `get_weather` veya `search_web` gibi araÃ§larÄ± nasÄ±l kullandÄ±ÄŸÄ±nÄ± gÃ¶rdÃ¼k. Peki ya ÅŸu senaryoyu dÃ¼ÅŸÃ¼nelim:

Bir "AraÅŸtÄ±rma AjanÄ±" (research_agent) web'i tarayarak bir rapor oluÅŸturuyor.
Bu raporu bir "Analiz AjanÄ±"na (analysis_agent) gÃ¶nderiyor.
"Analiz AjanÄ±" rapordaki verileri bir veritabanÄ±na sorgu atarak doÄŸruluyor.
SonuÃ§larÄ± bir "YazÄ± AjanÄ±"na (writing_agent) vererek son kullanÄ±cÄ±ya bir e-posta taslaÄŸÄ± hazÄ±rlatÄ±yor.

Bu **Ã§oklu-ajan (multi-agent)** sisteminde, ÅŸu kritik sorular ortaya Ã§Ä±kar:

* Bu ajanlar birbirleriyle nasÄ±l "konuÅŸacak"?
* "AraÅŸtÄ±rma AjanÄ±"nÄ±n bulduÄŸu rapor, "Analiz AjanÄ±" tarafÄ±ndan nasÄ±l eriÅŸilebilir olacak? (Durum/Context nasÄ±l paylaÅŸÄ±lacak?)
* Hangi ajanÄ±n hangi aracÄ± (veya veritabanÄ±nÄ±) kullanma yetkisi olduÄŸunu kim denetleyecek?

Bu "Ajan AnarÅŸisi" probleminin Ã§Ã¶zÃ¼mÃ¼, **Model Context Protocol (MCP)** gibi standartlaÅŸtÄ±rÄ±lmÄ±ÅŸ bir protokoldÃ¼r. MCP, bir API'den Ã§ok daha fazlasÄ±dÄ±r; ajanlarÄ±n Ã¼zerinde Ã§alÄ±ÅŸabileceÄŸi, **durumu (state), araÃ§larÄ± (tools) ve iletiÅŸimi yÃ¶neten bir iÅŸletim sistemi katmanÄ±dÄ±r.**

### Restoran MutfaÄŸÄ± Analojisi
Geleneksel API (OpenAI): Bir otomat gibidir. Para (prompt) atarsÄ±nÄ±z, Ã¼rÃ¼n (cevap) alÄ±rsÄ±nÄ±z. Her iÅŸlem birbirinden baÄŸÄ±msÄ±zdÄ±r (stateless).

**MCP OrtamÄ±:** Profesyonel bir restoran mutfaÄŸÄ± gibidir.
* **MCP Host/Server (Åef):** TÃ¼m mutfaÄŸÄ± (ortamÄ±) yÃ¶netir. Gelen sipariÅŸleri (hedefleri) alÄ±r, hangi aÅŸÃ§Ä±nÄ±n ne yapacaÄŸÄ±na karar verir.
* **MCP Client (AÅŸÃ§Ä±lar):** AjanlarÄ±n kendisidir. BÄ±Ã§aklarÄ± (araÃ§larÄ±) kullanÄ±rlar, birbirleriyle konuÅŸurlar.
* **Data Layer (Kiler/Depo):** TÃ¼m malzemelerin (veritabanlarÄ±, dosyalar, vektÃ¶r depolarÄ±) bulunduÄŸu yerdir. Herkes buradan malzeme Ã§eker.
* **Transport Layer (Ä°letiÅŸim/Ses):** Mutfaktaki "SipariÅŸi ver!", "HazÄ±r!" gibi komutlarÄ±n iletilme ÅŸeklidir.

### MCP'nin Ã‡ekirdek BileÅŸenleri (Teknik Derinlik)
MCP, ajanlarÄ±n otonom Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak iÃ§in gereken tÃ¼m "tesisatÄ±" (plumbing) saÄŸlar.

#### 1. MCP Host ve Sunucu (OrkestratÃ¶r)
Bu, sistemin beyni ve denetleyicisidir. AjanÄ±n ReAct dÃ¶ngÃ¼sÃ¼nÃ¼ Ã§alÄ±ÅŸtÄ±ran basit bir `while` dÃ¶ngÃ¼sÃ¼nden Ã§ok daha fazlasÄ±dÄ±r.

* **Durum YÃ¶netimi (State Management):** Bir ajanÄ±n "hafÄ±zasÄ±nÄ±" tutar. KullanÄ±cÄ±yla yapÄ±lan Ã¶nceki konuÅŸmalar, RAG'dan gelen baÄŸlam, ajanÄ±n kendi "dÃ¼ÅŸÃ¼nce" adÄ±mlarÄ±... tÃ¼m bu baÄŸlam (context) Host tarafÄ±ndan yÃ¶netilir.
* **AraÃ§ KomisyonculuÄŸu (Tool Brokering):** Ajan bir aracÄ± (Ã¶rn. `send_email`) kullanmak istediÄŸinde, isteÄŸi doÄŸrudan yapmaz. Ä°steÄŸi Host'a iletir. Host, bu ajanÄ±n o aracÄ± kullanma yetkisi olup olmadÄ±ÄŸÄ±nÄ± (**gÃ¼venlik/yetkilendirme**) kontrol eder, aracÄ± Ã§alÄ±ÅŸtÄ±rÄ±r ve sadece sonucunu ajana geri dÃ¶ndÃ¼rÃ¼r. Bu, ajanÄ±n kendisinin hassas API anahtarlarÄ±na veya veritabanÄ± baÄŸlantÄ±larÄ±na sahip olmasÄ±nÄ± engeller, bu da gÃ¼venliÄŸi muazzam artÄ±rÄ±r.
* **YaÅŸam DÃ¶ngÃ¼sÃ¼ YÃ¶netimi (Lifecycle Management):** AjanlarÄ± baÅŸlatÄ±r, durdurur, askÄ±ya alÄ±r ve izler (monitoring).

#### 2. MCP Ä°stemcisi (AjanÄ±n AdaptÃ¶rÃ¼)
Bu, ajanÄ±n "beyni" (LLM/ReAct mantÄ±ÄŸÄ±) ile Host'un "dÃ¼nyasÄ±" arasÄ±ndaki kÃ¶prÃ¼dÃ¼r.

AjanÄ±n kendisi (yani Llama 3 veya GPT-4 tabanlÄ± karar mekanizmasÄ±) teknik olarak MCP'den habersizdir. O sadece "DÃ¼ÅŸÃ¼nce, Eylem, GÃ¶zlem" dÃ¶ngÃ¼sÃ¼nde Ã§alÄ±ÅŸÄ±r. Ä°stemci (Client), ajanÄ±n "Eylem" olarak Ã¼rettiÄŸi JSON Ã§aÄŸrÄ±sÄ±nÄ± alÄ±r, bunu MCP'nin anlayacaÄŸÄ± standart bir protokole (Transport Layer Ã¼zerinden) Ã§evirir ve Host'a gÃ¶nderir.

Bu ayrÄ±m, **modÃ¼lerlik iÃ§in kritiktir**. YarÄ±n LLM'inizi GPT-4'ten Claude 3'e deÄŸiÅŸtirmek istediÄŸinizde, tÃ¼m MCP altyapÄ±sÄ±nÄ± deÄŸil, sadece "istemciye" takÄ±lÄ± olan "beyin" modÃ¼lÃ¼nÃ¼ deÄŸiÅŸtirirsiniz.

#### 3. Veri KatmanÄ± (PaylaÅŸÄ±mlÄ± HafÄ±za)
Bu, tÃ¼m ajanlarÄ±n ve araÃ§larÄ±n eriÅŸtiÄŸi "tekil doÄŸru kaynaktÄ±r" (Single Source of Truth). AjanÄ±n geÃ§ici hafÄ±zasÄ±nÄ±n (sohbet geÃ§miÅŸi) Ã¶tesinde, kalÄ±cÄ± (persistent) bilgiyi tutar.

Bu katman, soyut bir ÅŸekilde ÅŸunlarÄ± yÃ¶netir:
* **VektÃ¶r DepolarÄ±:** (Bkz. BÃ¶lÃ¼m 13) RAG iÃ§in kullanÄ±lan anlamsal hafÄ±za.
* **Ä°liÅŸkisel VeritabanlarÄ± (SQL):** KullanÄ±cÄ± profilleri, izinler, sipariÅŸ kayÄ±tlarÄ±.
* **Belge DepolarÄ± (S3, Disk):** AjanlarÄ±n Ã¼rettiÄŸi veya okuduÄŸu dosyalar (PDF'ler, CSV'ler).
* **Ã–nbelleÄŸe Alma (Caching):** SÄ±k kullanÄ±lan verilere (Ã¶rn. kullanÄ±cÄ± profili) veya araÃ§ Ã§aÄŸrÄ±larÄ±na (Ã¶rn. dÃ¼nkÃ¼ hava durumu) tekrar tekrar eriÅŸimi hÄ±zlandÄ±rmak iÃ§in kritik bir optimizasyon katmanÄ±dÄ±r.

#### 4. TaÅŸÄ±ma KatmanÄ± (Sistem Sinir AÄŸÄ±)
Bu, verinin Host, Client ve Data Layer arasÄ±nda nasÄ±l hareket ettiÄŸini tanÄ±mlayan katmandÄ±r. SeÃ§im, performans ve gecikme (latency) Ã¼zerinde doÄŸrudan etkilidir.

* **REST/HTTP:** Harici istemcilerin (Ã¶rn. bir web uygulamasÄ±) sisteme ilk isteÄŸi gÃ¶ndermesi iÃ§in yaygÄ±ndÄ±r (standart, kolay).
* **WebSockets:** Ä°ki yÃ¶nlÃ¼, kalÄ±cÄ± baÄŸlantÄ±lar iÃ§in idealdir. Host'un, iÅŸ bittiÄŸinde istemciye (kullanÄ±cÄ± arayÃ¼zÃ¼ne) anÄ±nda bir "cevap hazÄ±r" mesajÄ± gÃ¶ndermesini saÄŸlar (streaming).
* **gRPC:** Ã–zellikle iÃ§ (internal) servis iletiÅŸimleri (Ã¶rn. Host'un Veri KatmanÄ± ile veya farklÄ± mikroservis ajanlarÄ±n kendi aralarÄ±nda) iÃ§in kullanÄ±lÄ±r. HTTP/JSON'a gÃ¶re Ã§ok daha **dÃ¼ÅŸÃ¼k gecikmeli, yÃ¼ksek performanslÄ±** ve verimli bir ikili (binary) protokoldÃ¼r.

**Ã–zetle, MCP; otonom ajanlarÄ± birer "solo sanatÃ§Ä±" olmaktan Ã§Ä±karÄ±p, birlikte karmaÅŸÄ±k hedeflere ulaÅŸabilen, gÃ¼venli ve yÃ¶netilebilir bir "orkestraya" dÃ¶nÃ¼ÅŸtÃ¼ren temel altyapÄ± ve protokoller bÃ¼tÃ¼nÃ¼dÃ¼r.**