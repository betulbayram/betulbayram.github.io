## Bölüm 17: MCP ile Geliştirme - Sunucudan İstemciye Ajan Mimarisi
MCP mimarisinde geliştirme yapmak, iki ayrı ama birbiriyle sürekli iletişim halinde olan bileşeni inşa etmek demektir: Ajanın "dünyasını" ve "araçlarını" yöneten **Sunucu (Host)** ve ajanın "beynini" (LLM) barındıran **İstemci (Client)**.

### 1. MCP Sunucusunu (Host) İnşa Etmek: Ajanın Orkestratörü
MCP Sunucusu, ajanların "dış dünya" ile etkileşime girdiği denetleyici ve aracı katmandır. Bu, basit bir API'den çok daha fazlasıdır; **durum (state)** yönetimi yapabilen, güvenliği sağlayan ve araçları yürüten bir orkestratördür.

Bir MCP Sunucusu inşa etmenin teknik adımları:

#### API Arayüzünü Tanımlamak (Standardizasyon)
Sunucunuzun, istemcilerin (ajanların) bağlanacağı standart yollara (endpoints) ihtiyacı vardır. Minimal bir MCP sunucusu, RESTful prensiplerle şunları sağlamalıdır:
* `POST /v1/contexts`: Yeni bir "bağlam" veya "oturum" (session) başlatır. Ajanın tüm hafızası (sohbet geçmişi, değişkenler) bu bağlama (context) bağlı bir `context_id` ile tutulur.
* `POST /v1/contexts/{context_id}/run`: Ajanın ana etkileşim noktasıdır. İstemci, bir sonraki "düşüncesini" veya "eylem niyetini" buraya gönderir.
* `GET /v1/contexts/{context_id}/state`: Ajanın mevcut durumunu (hafızasını) dışarıdan sorgulamak için kullanılır.
* `GET /v1/tools`: Bu bağlam için ajanın kullanmasına izin verilen araçların listesini ve şemalarını döndürür.

#### Durum Yönetimi (Stateful Olmak)
En kritik kısım budur. Ajanlar, doğaları gereği "durum bilgisi" (stateful) gerektirir; önceki adımları hatırlamak zorundadırlar. HTTP ise "durumsuz" (stateless) bir protokoldür. Sunucu, bu ikisi arasında köprü kurmalıdır.
* Gelen `context_id` ile ilgili tüm sohbet geçmişini, önceki "Düşünce/Eylem/Gözlem" adımlarını ve hafızadaki değişkenleri hızlıca yüklemelidir.
* Bu durum, geliştirme (`local`) için in-memory bir sözlükte tutulabilir, ancak üretim (`remote`) için `Redis` (hız için) veya `DynamoDB`/`Postgres` (kalıcılık için) gibi harici bir depoda tutulmalıdır.

#### Araç Orkestrasyonu ve Güvenlik
Ajan (istemci) bir aracı kullanmak istediğinde, aracı kendisi çalıştırmaz. Sadece niyetini sunucuya bildirir.
* **Ajan (İstemci):** `Action: { "tool_name": "get_database_user", "args": { "user_id": 123 } }`
* **Sunucu (Host):** Bu isteği alır. `ToolRegistry` (Araç Kayıt Defteri) üzerinden `get_database_user` aracını bulur. Ajanın bu aracı çağırma yetkisi (**authorization**) olup olmadığını kontrol eder.
* **Güvenli Yürütme:** Sunucu, kendi ortamında, güvenli bir şekilde (API anahtarları ve veritabanı bağlantıları sunucuda saklanır, ajanda değil) bu aracı çalıştırır.
* **Yanıt:** Sadece aracın çıktısını ("Observation") istemciye geri döndürür.

### 2. MCP İstemcisini (Client) İnşa Etmek: Ajanın "Beyin" Adaptörü
İstemci, ajanın "beynini" (LLM'in karar verme mantığı) barındıran ve bu beyni MCP Sunucusunun standartlarına "tercüme eden" adaptördür.

#### LLM Mantık Çekirdeği (ReAct Döngüsü)
* Bölüm 15'te gördüğümüz `ReAct (Reason + Act)` döngüsünün mantığı burada, istemcide yaşar. İstemci, bir `while` döngüsü içinde:
    1.  Mevcut durumu (hafıza + son gözlem) alır.
    2.  Bunu bir LLM'e (örn. OpenAI, Ollama) göndererek bir "Düşünce" (Thought) ve "Eylem" (Action) üretmesini ister.
    3.  LLM'in çıktısını analiz eder.

#### Sunucu ile İletişim (İstek/Yanıt Formatlama)
* Eğer LLM'in ürettiği "Eylem" bir araç çağrısı ise (örn. `get_weather`), istemci bu aracı çalıştırmaz. Bu "Eylem" niyetini paketler ve MCP Sunucusunun `.../run` endpoint'ine `POST` eder.
* Eğer LLM'in çıktısı nihai bir cevap ise (artık araca ihtiyacı yoksa), bu cevabı son kullanıcıya gösterir ve döngüyü sonlandırır.

#### Soyutlama (Abstraction)
* İstemcinin güzelliği, LLM "beyninin" ağ detaylarından tamamen habersiz olmasını sağlamasıdır. LLM, `get_weather` aracını çağırdığını düşünür; bu aracın bir MCP Sunucusu üzerinden `http://localhost:8000`'de mi yoksa `https://api.mycloud.com`'da mı çalıştığını bilmez ve bilmemelidir. İstemci bu soyutlamayı sağlar.

### 3. Dağıtım Modelleri: Yerel (Local) vs. Uzak (Remote)
Bu Sunucu/İstemci mimarisini nasıl dağıttığınız, projenizin amacını (geliştirme mi, üretim mi) belirler.

#### Senaryo A: Yerel (Local) Dağıtım (Geliştirme, Test, Gizlilik)
Bu, hızlı prototipleme ve hata ayıklama (debugging) için idealdir.

* **Sunucu (Host):** `python mcp_server.py` komutuyla doğrudan kendi bilgisayarınızda (laptop/desktop) çalışır. `127.0.0.1:8000` (localhost) adresini dinler. Durum yönetimi (state management) genellikle basit bir Python sözlüğü (in-memory) veya lokal bir `SQLite` dosyasıdır.
* **İstemci (Client):** `base_url="http://127.0.0.1:8000"` adresine bağlanacak şekilde yapılandırılır. Ajanın "beyni" olan LLM bile `Ollama` (Bölüm 9) kullanılarak yerel olarak çalıştırılabilir.
* **Avantajlar:** Sıfır ağ gecikmesi, tam veri gizliliği (hiçbir şey makinenizden çıkmaz), ücretsiz (özellikle yerel LLM'ler ile) ve kolay hata ayıklama.
* **Dezavantajlar:** Donanımınızın (RAM/VRAM) limitleriyle kısıtlıdır. Dışarıdan erişilemez (ancak `ngrok` gibi tünelleme araçları geçici testler için kullanılabilir).

#### Senaryo B: Uzak (Remote/Cloud) Dağıtım (Üretim, Ölçeklenebilirlik)
Bu, sistemin binlerce kullanıcıya hizmet vermesi gereken üretim (production) mimarisidir.

* **Sunucu (Host):**
    * **Paketleme:** MCP Sunucusu bir `Docker container`'ı olarak paketlenir.
    * **Dağıtım:** Bu imaj, `AWS (ECS/EKS)`, `Azure (AKS)` veya `Google Cloud (GKE/Cloud Run)` gibi bir bulut sağlayıcısına dağıtılır.
    * **Ölçeklendirme:** Bir `Load Balancer` (Yük Dengeleyici) arkasında çalışır ve `Auto-Scaling` (Otomatik Ölçeklendirme) grupları, trafik arttıkça sunucu kopyalarının sayısını (örneğin 1'den 50'ye) otomatik olarak artırır.
    * **Güvenlik:** Endpoint, `HTTPS` (TLS sertifikası) ile korunur. Gelen her istek bir `API Anahtarı` veya `JWT (JSON Web Token)` ile doğrulanır (authentication).
    * **İzleme (Monitoring):** Loglar ve metrikler (`CloudWatch`, `Datadog`, `Prometheus`) sistemin sağlığını izlemek için merkezi bir yerde toplanır.
* **Durum (State) Yönetimi:** Burası en kritik farktır. Otomatik ölçeklenen bir ortamda sunucunun kendisi "durumsuz" (stateless) olmalıdır. `context_id` ile ilişkili tüm ajan hafızası, `Redis` (hızlı erişim için) veya `Postgres`/`DynamoDB` (kalıcı depolama için) gibi paylaşımlı, harici bir veritabanında saklanmalıdır.
* **İstemci (Client):** Artık `base_url="https://api.sirketim.com/mcp"` gibi genel (public), güvenli ve ölçeklenebilir bir adrese bağlanır.