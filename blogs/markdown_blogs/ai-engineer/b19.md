# BÃ¶lÃ¼m 19: Yapay Zeka Destekli GeliÅŸtirme AraÃ§larÄ± ğŸ› ï¸ - Sadece Kod Yazmak DeÄŸil, Kodu "AkÄ±l YÃ¼rÃ¼tmek"
GeliÅŸtiricinin araÃ§ kutusu, on yÄ±llar boyunca derleyicilerden (compiler), hata ayÄ±klayÄ±cÄ±lara (debugger) ve akÄ±llÄ± editÃ¶rlere (IntelliSense) doÄŸru evrildi. Her adÄ±m, mekanik iÅŸleri otomatize ederek geliÅŸtiricinin asÄ±l problem olan mantÄ±k Ã¼zerine odaklanmasÄ±nÄ± saÄŸladÄ±.

Åimdi, bu evrimin en bÃ¼yÃ¼k sÄ±Ã§ramasÄ±nÄ± yaÅŸÄ±yoruz. ArtÄ±k elimizdeki araÃ§lar, bir sonraki kelimeyi veya satÄ±rÄ± "tamamlamanÄ±n" Ã¶tesine geÃ§erek, **niyetimizi (intent)** anlayan, tÃ¼m bir kod bloÄŸunu oluÅŸturan ve hatta projemizin tamamÄ± hakkÄ±nda bizimle "sohbet eden" birer **"yardÄ±mcÄ± pilot" (copilot)** haline geldiler.

Bu, LLM'lerin (BÃ¼yÃ¼k Dil Modelleri) GitHub gibi platformlardaki milyarlarca satÄ±r aÃ§Ä±k kaynak kod Ã¼zerinde eÄŸitilmesiyle mÃ¼mkÃ¼n oldu. Modeller, kodun sadece sÃ¶zdizimini (syntax) deÄŸil, aynÄ± zamanda yaygÄ±n desenlerini (design patterns), mantÄ±ÄŸÄ±nÄ± ve "niyetini" de Ã¶ÄŸrendiler.

Bu araÃ§larÄ± Ã¼Ã§ ana kategoride inceleyebiliriz:

## 1. Kategori: AkÄ±llÄ± Kod Tamamlama (Intelligent Code Completion)
Bu kategori, yapay zekanÄ±n geliÅŸtirici akÄ±ÅŸÄ±na girdiÄŸi ilk ve en yaygÄ±n yÃ¶ntemdir. Bunlar, geleneksel "otomatik tamamlamanÄ±n" (autocomplete) Ã§ok Ã¶tesindedir; yazdÄ±ÄŸÄ±nÄ±z koda ve yorumlara bakarak bir sonraki adÄ±mÄ± veya tÃ¼m fonksiyon gÃ¶vdesini tahmin ederler.

* **Ã–rnekler:** GitHub Copilot, Tabnine

### NasÄ±l Ã‡alÄ±ÅŸÄ±rlar?
* **GitHub Copilot:** Temelinde OpenAI's Codex (ve ÅŸimdi daha yeni GPT modelleri) bulunur. EditÃ¶rÃ¼nÃ¼zdeki mevcut dosyanÄ±n iÃ§eriÄŸini (ve bazen diÄŸer aÃ§Ä±k sekmelerdeki baÄŸlamÄ±) alÄ±r.
* Siz bir fonksiyon adÄ± yazdÄ±ÄŸÄ±nÄ±zda (Ã¶rn. `def calculate_fibonacci(n):`) veya bir yorum bÄ±raktÄ±ÄŸÄ±nÄ±zda (Ã¶rn. `// VeritabanÄ±na kullanÄ±cÄ±yÄ± kaydeden fonksiyon`), Copilot bu baÄŸlamÄ± bir prompt olarak kullanarak bir sonraki kod bloÄŸunu tahmin eder ve size soluk bir metin olarak Ã¶nerir.

### Teknik Etkisi (MÃ¼hendislik Perspektifi)
* GeliÅŸtiricinin rolÃ¼nÃ¼ "yazmaktan" (typing), "incelemeye" (reviewing) kaydÄ±rÄ±r.
* "Boilerplate" (sÃ¼rekli yazÄ±lan standart kod) olarak tabir edilen iÅŸleri (Ã¶rn. birim testleri, API endpoint'i oluÅŸturma, dosya okuma/yazma) sÄ±fÄ±ra indirir.
* **Risk:** "Copilot tuzaÄŸÄ±" olarak bilinen bir durum yaratabilir. Ã–nerilen kod doÄŸru gÃ¶rÃ¼nebilir ancak iÃ§inde ince gÃ¼venlik aÃ§Ä±klarÄ± (Ã¶rn. SQL enjeksiyonuna aÃ§Ä±k sorgular) veya mantÄ±k hatalarÄ± barÄ±ndÄ±rabilir. KÄ±demli (senior) bir bakÄ±ÅŸ aÃ§Ä±sÄ±, bu Ã¶nerileri "doÄŸru" kabul etmek yerine "hÄ±zlÄ± bir ilk taslak" olarak gÃ¶rmek ve mutlaka gÃ¶zden geÃ§irmek zorundadÄ±r.

## 2. Kategori: Yapay Zeka OdaklÄ± IDE'ler (AI-Native IDEs)
Bu, bir sonraki evrim adÄ±mÄ±dÄ±r. Burada yapay zeka, editÃ¶rÃ¼nÃ¼ze sonradan eklenen bir "eklenti" (plugin) deÄŸil, IDE'nin ta kendisidir. TÃ¼m deneyim, yapay zeka ile etkileÅŸim Ã¼zerine kuruludur.

* **Ã–rnek:** Cursor

### NasÄ±l Ã‡alÄ±ÅŸÄ±r?
* Cursor, temelde VS Code'un tanÄ±dÄ±k arayÃ¼zÃ¼nÃ¼ alÄ±r ancak onu derin bir yapay zeka entegrasyonuyla "sarar".
* **SatÄ±r Ä°Ã§i Sohbet (Inline Chat):** Yandaki bir sohbet penceresinden daha fazlasÄ±dÄ±r. Kodunuzun ortasÄ±nda `Cmd+K` gibi bir tuÅŸa basarak doÄŸrudan bir prompt aÃ§arsÄ±nÄ±z. Bir fonksiyonu seÃ§ip, "Bu fonksiyonu async/await kullanacak ÅŸekilde yeniden yaz" diyebilirsiniz. Cursor, deÄŸiÅŸikliÄŸi bir fark (diff) olarak doÄŸrudan kodunuzun Ã¼zerine uygular ve sizden onay (Accept/Reject) bekler. Bu, inanÄ±lmaz hÄ±zlÄ± bir refactoring (yeniden dÃ¼zenleme) saÄŸlar.
* **Proje Ã‡apÄ±nda BaÄŸlam (Repository-wide Context):** Cursor'Ä±n asÄ±l gÃ¼cÃ¼ budur. Projenizdeki `@` sembolÃ¼nÃ¼ kullanarak, "@DatabaseService.js dosyasÄ±ndaki veritabanÄ± ÅŸemasÄ±na bakarak bu dosyaya bir 'updateUser' fonksiyonu yaz" diyebilirsiniz. Cursor, tÃ¼m projenizi (gerekirse bir vektÃ¶r veritabanÄ±na) indeksleyerek, Copilot'un aksine sadece aÃ§Ä±k olan dosyayÄ± deÄŸil, projenin tamamÄ±nÄ± "anlar". Bu, projenize Ã¶zel bir RAG sistemi (BÃ¶lÃ¼m 14) kullanmak gibidir.

## 3. Kategori: Harici Destek AraÃ§larÄ± (External Support Tools)
Bu araÃ§lar, doÄŸrudan kod editÃ¶rÃ¼nÃ¼zÃ¼n iÃ§inde yaÅŸamak zorunda deÄŸildir ancak geliÅŸtirme iÅŸ akÄ±ÅŸÄ±nÄ±zÄ± (workflow) besler ve desteklerler.

### a) TarayÄ±cÄ± TabanlÄ± Asistanlar ve ÃœreteÃ§ler
* **Claude:** Anthropic'in bu modeli, devasa baÄŸlam penceresi (context window) ile Ã¼nlÃ¼dÃ¼r. Binlerce satÄ±rlÄ±k bir kod dosyasÄ±nÄ± veya 100 sayfalÄ±k bir teknik dokÃ¼manÄ± tek seferde kopyalayÄ±p yapÄ±ÅŸtÄ±rabilir ve "Bu kodda bir 'memory leak' var mÄ±?" veya "Bu dokÃ¼manÄ±n en Ã¶nemli 5 noktasÄ±nÄ± Ã¶zetle" gibi sorular sorabilirsiniz.
* **v0 (Vercel):** Bu, yapay zekanÄ±n multimodal (BÃ¶lÃ¼m 18) yeteneklerinin tasarÄ±ma uygulandÄ±ÄŸÄ± harika bir Ã¶rnektir. v0'a kod yazmazsÄ±nÄ±z; bir kullanÄ±cÄ± arayÃ¼zÃ¼nÃ¼ (UI) tarif edersiniz. "ÃœÃ§ kademeli bir fiyatlandÄ±rma tablosu, ortadaki plan 'PopÃ¼ler' olarak vurgulansÄ±n." v0, bu tarife uygun React (Tailwind CSS) kodunu Ã¼retir. Bu, mantÄ±k deÄŸil, gÃ¶rsel tasarÄ±m Ã¼reten bir araÃ§tÄ±r.

### b) BaÄŸlam ve Kod ParÃ§acÄ±ÄŸÄ± YÃ¶netimi
* **Pieces:** GeliÅŸtiricilerin en bÃ¼yÃ¼k sorunlarÄ±ndan biri, daha sonra kullanmak Ã¼zere bulduklarÄ± faydalÄ± kod parÃ§acÄ±klarÄ±nÄ± (snippets) yÃ¶netmektir (Gist, not defterleri, daÄŸÄ±nÄ±k dosyalar vb.).
    * **NasÄ±l Ã‡alÄ±ÅŸÄ±r:** Pieces, masaÃ¼stÃ¼nÃ¼zde Ã§alÄ±ÅŸan akÄ±llÄ± bir "kod karalama defteri" gibidir. KopyaladÄ±ÄŸÄ±nÄ±z her kod parÃ§acÄ±ÄŸÄ±nÄ± (snippet) otomatik olarak algÄ±layÄ±p kaydedebilir. AsÄ±l yapay zeka Ã¶zelliÄŸi, bu parÃ§acÄ±ÄŸÄ± anlamasÄ±dÄ±r: Kodu otomatik olarak etiketler ("Python", "FastAPI", "Async"), bir baÅŸlÄ±k atar ve en Ã¶nemlisi, bu parÃ§acÄ±klarÄ± doÄŸal dil ile aranabilir hale getirir.
    * **Teknik Etkisi:** ArtÄ±k "PostgreSQL'e baÄŸlanan o Python kodunu nereye kaydetmiÅŸtim?" diye dÃ¼ÅŸÃ¼nmenize gerek kalmaz. Pieces'a "python postgres connect" yazmanÄ±z yeterlidir. Bu, kendi kiÅŸisel kod bilginiz iÃ§in oluÅŸturulmuÅŸ yerel bir arama motoru (RAG) gÃ¶revi gÃ¶rÃ¼r.

---
**Ã–zetle,** bu araÃ§lar bizi "yazÄ±lÄ±mcÄ±" olmaktan Ã§Ä±karmaz. Tam tersine, bizi sÄ±kÄ±cÄ± ve tekrarlayan mekanik iÅŸlerden kurtararak, zamanÄ±mÄ±zÄ± asÄ±l deÄŸerli olan iÅŸe, yani mimari, kullanÄ±cÄ± deneyimi ve karmaÅŸÄ±k problem Ã§Ã¶zme gibi alanlara ayÄ±rmamÄ±zÄ± saÄŸlayan birer **"gÃ¼Ã§ Ã§arpanÄ±" (force multiplier)** haline gelirler.